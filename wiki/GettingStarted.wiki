#summary Automatic classless route summarization

<wiki:toc max_depth="1" />

= Introduction =

The source here includes an IP address class, the AcrsRoute4 class for IPv4 summarization, and a demonstration command line program that uses the classes. The code is written in C++.

Typically, route summarization is handled either manually or classfully. This library handles route summarization classlessly, and can be used to perform automatic summarization of arbitrary/changing lists of routes. The library is also useful for optimizing network filtering in various applications (such as access lists or firewall rules) by converting arbitrarily long lists of prefixes into their most summarized form.

= Explained =

The algorithm ACRS uses is very simple. There are two steps: main summarization and overlap removal.

Main summarization operates on lists of routes consisting of, at least, a network address, a prefix length, and a metric. In the implementation here, it operates on routes of the AcrsRoute4 class. Before summarizing, ACRS sorts the list in the following manner:

    # Primary sort by metric (sort order doesn't matter)
    # Secondary by prefix length in descending order
    # Tertiary sort by network address in ascending order

Once the list is sorted, each route in the list is compared with the next route in the list. For any two routes in the list to be summarized, these conditions must be true:

  # Their metrics must match
  # Their prefix lengths must match
  # The broadcast address of the lower route, plus one, must be equal to the network address of the higher route
  # The network address of the potential summary route must be equal to the network address of the lower route

If the above conditions are met, the two routes can be summarized by discarding the higher route and decreasing the lower route's metric by 1. Using recursion, this process will summarize all routes within the list as much as possible without using addresses NOT specified by at least one route. For example, ACRS can summarize 192.168.16.0/25 and 192.168.16.128/25 into 192.168.16.0/24, but an administrator might know that it's safe to summarize these routes all the way down to 192.168.0.0/16. Since this information is not presented to ACRS, it has no way to account for such situations.

Once main summarization is finished, overlap removal gets rid of routes that specify identical address space. For example, 10.0.0.0/8 and 10.250.24.0/24 specify overlapping address space, so the less specific prefix can be used. (Note that this can only be done when the metric of the less specific route is better than the metric of the more specific route. It could also lead to unexpected routing in some networks, particularly if you get creative with manual summarization. This is discussed in Why use it?, below.)

The first step is to re-sort the routes as follows:

  # Primary sort by network address in ascending order
  # Secondary sort by prefix length in ascending order
  # Tertiary sort by metric in ascending order

Once the list is sorted, each route is again compared to the next route in the list. If the following two conditions are true, the networks may be summarized:

  # The higher route's network address ANDed with the lower route's subnet mask is equal to the lower route's network address
  # The metric of the lower route must be less than or equal to the metric of the higher route

When two routes are found to overlap, the higher network is removed from the list.

This is necessary because main summarization's rules for summarizing routes will not catch overlapping address space.

One additional note, which may come up as you play with the demo program:

The address added to the route list is not assumed to be a network address, necessarily. The network ID is determined as though the IP address given were a host address; that is, the address is ANDed with the mask to make sure it's a valid network ID. For example, if you specify 192.168.1.5/24, or any other address in the 192.168.1.0/24 range, this is fine; the network ID of 192.168.1.0/24 is used, not the IP address specified.

= Why use it? =

Almost any network that is large enough to _need_ summarization already has someone that thought out its design well enough to provide a good set of summary routes; if not, not having automatically summarized routes is probably the least of the network's problems.

Plus, changing the prefix length would influence routing decisions in ways that may not always be desirable. It seems that this will work best when no manual summarization is already being done. For example, overlap removal would be less-than-useful in situations where a router advertises a default route -- all other routes would be removed.

I wrote this mainly as a curiosity that I might integrate into another for-fun project of mine to provide automatic route summarization: http://code.google.com/p/advrp/

However, this can also be useful as a general purpose tool whenever large numbers of IP addresses need to be collated into a list and summarization is desirable, such as for ACLs/firewall rules. If you have a tool that generated a list of 1000 specific IP addresses you wish to blacklist and you suspect there is some summarization that can be done, feed that list through ACRS. Any summarization that is possible, ACRS will do, because it can consider individual IP addresses as host routes. And, it will not mis-use a summary address that blocks extra IPs by accident -- which you may do if you haven't had coffee.

Another possible use for ACRS would be in routing protocol for networks where route summarization is possible, but manual summarization isn't feasible, like randomly dispersed sensor networks or MANETs. Clusters of nodes must be able to form into a hierarchy (which is, admittedly, the more difficult undertaking), then two clusters can advertise summary routes to each other rather than a route for each network. The downside to this is that if a single route fails from within the summary, the entire summary must be removed and usable routes/summaries recomputed. This complicates things, and would negatively affect routing to reachable subnets without additional measures. Preemptively adding the necessary less-summarized routes before removing a summary could help mitigate the impact of this.

Using ACRS sacrifices some processing power for less memory usage (routing tables), so that is another consideration. The method used for summarization can be optimized to reduce processing, and only needs to be recomputed when routes change.

= Obtaining and building =

You can download the latest source either from the tarball on the Downloads tab or using subversion. Right now, there is no difference between the tarball and the subversion source, so getting the tarball is probably easiest (and it includes a precompiled binary).

== From the tar file ==

Steps:
  # Download the tarball
  # Extract the source code
  # Either use the precompiled acrs-demo binary (in which case you're done), or install a C++ compiler and build from source

For a Debian-based system:

{{{
wget http://acrs.googlecode.com/files/acrs-demo_0.1.tar.gz   # Replace version number if necessary
tar -xzf acrs-demo_0.1.tar.gz
cd acrs_demo
./acrs-demo
}}}

At this point, you can use the precompiled acrs-demo program. If you want to compile the source code yourself instead of using the precompiled program, you'll need to install a C++ compiler. See the following steps:

{{{
sudo apt-get install g++
cd acrs_demo
g++ -o acrs-demo *.cpp
./acrs-demo
}}}

== From subversion ==

The general process:
  # Install subversion
  # Install a C++ compiler
  # Download the code from googlecode using subversion
  # Compile the code
  # Run the demo program

For a Debian-based system:

{{{
sudo apt-get install subversion g++
svn checkout http://acrs.googlecode.com/svn/trunk/ acrs-read-only
cd acrs-read-only/c++
g++ -o acrs-demo acrs.cpp acrs-demo.cpp ip4addr.cpp
./acrs-demo
}}}

= Using the demo =

After compiling, try this with the demo:

{{{
./acrs-demo 10.0.0.0/26 10.0.0.64/26 10.0.0.128/25
}}}

Output:

{{{
10.0.0.0/24 in 0
}}}

Try some other routes, too. The "in 0" message is the metric, which can be ignored while you're using the demo. The library supports different metrics, but the demo does not. It assigns all routes a metric of 0, so they are all eligible to be summarized with each other as far as that condition is concerned.

You can enable logging by passing the -l flag as the first argument to the acrs-demo command. For example:

{{{
./acrs-demo -l 10.0.1.0/26 10.0.1.64/26 10.0.0.0/24 10.0.1.128/25 10.0.0.0/16 10.0.0.0/16
}}}

Output:

{{{
* Main summarization:
*   Summarized '10.0.1.0/26 in 0' and '10.0.1.64/26 in 0' into '10.0.1.0/25 in 0'
*   Summarized '10.0.1.0/25 in 0' and '10.0.1.128/25 in 0' into '10.0.1.0/24 in 0'
*   Summarized '10.0.0.0/24 in 0' and '10.0.1.0/24 in 0' into '10.0.0.0/23 in 0'
* Overlap removal:
*   Removing '10.0.0.0/16 in 0', which falls within '10.0.0.0/16 in 0'
*   Removing '10.0.0.0/23 in 0', which falls within '10.0.0.0/16 in 0'
* Finished. List was summarized.
10.0.0.0/16 in 0
}}}

For non-routing purposes (such as access lists), lists of individual IP addresses can be summarized by ignoring the metric (which the demo already does) and giving each address a /32 mask:

{{{
./acrs-demo 1.1.1.7/32 1.1.1.6/32 1.1.1.4/32 1.1.1.5/32
}}}

Output:

{{{
1.1.1.4/30 in 0
}}}

This works because 1.1.1.4/32 and 1.1.1.5/32 are first summarized into 1.1.1.4/31, then 1.1.1.6/32 and 1.1.1.7/32 are summarized into 1.1.1.6/31, and finally 1.1.1.4/31 and 1.1.1.6/31 are summarized into 1.1.1.4/30.

These networks will not be summarized:

{{{
./acrs-demo 1.1.1.5/32 1.1.1.6/32
}}}

Output:

{{{
1.1.1.5/32 in 0
1.1.1.6/32 in 0
}}}

Why? The real life justification is that 1.1.1.5/31 is not a valid network ID. In the code, this is checked by ensuring that a potential summary route's network address is equal to the lower route's network address. The potential summary route, 1.1.1.5/31, has a network address of 1.1.1.4. This is not equal to the network address of the lower route (1.1.1.5), so the routes cannot be summarized.

The following will work, however:

{{{
./acrs-demo 1.1.1.5/32 1.1.1.4/32
}}}

Output:

{{{
1.1.1.4/31 in 0
}}}

The order of routes on the command line doesn't matter; they are sorted as needed by the library.

= Partial TODO =

  # It would be nice for ACRS to be templated
  # "Logging" was an afterthought, so the code is ugly right now
  # This was re-written from C, and some formatting style is still off (valid_snmask_i vs camel case)
  # Code is close-to-usable in a C program. Would be nice to make the code fully usable in both C and C++ programs. For C++ specific code, it would be nice to make use of overloaded get`*`() functions so we don't have to pass a null pointer to retrieve an address as an integer.
  # Make sure IP address library in use handles different endianness?
  # Write a howto on using this with IPSet